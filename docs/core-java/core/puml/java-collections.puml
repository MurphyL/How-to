@startuml

interface Iterable<T> {

    Iterator<T> iterator()

}

interface Map<K,V>

interface Collection<E> extends Iterable {

    int size()

    Object[] toArray()
    <T> T[] toArray(T[] a)

    boolean add(E e)
    boolean addAll(Collection<? extends E> c)
    boolean remove(Object o)
    void clear()

    boolean retainAll(Collection<?> c)

    boolean isEmpty()
    boolean contains(Object o)
    boolean containsAll(Collection<?> c)
}

interface Queue<E> extends Collection {

    boolean offer(E e)
    E poll()
    E element()
    E peek()
}

interface Deque<E> extends Queue {

    void addFirst(E e)
    void addLast(E e)
    boolean offerFirst(E e)
    boolean offerLast(E e)
    E removeFirst()
    E removeLast()
    E pollFirst()
    E pollLast()
    E getFirst()
    E getLast()
    E peekFirst()
    E peekLast()
}

class PriorityQueue<E> extends Queue

interface List<E> extends Collection {

    int indexOf(Object o)
    int lastIndexOf(Object o)

    ListIterator<E> listIterator(int index)

    List<E> subList(int fromIndex, int toIndex)
}

interface Set<E> extends Collection


class ArrayList<E> implements List, RandomAccess

class LinkedList<E> implements List, Deque


class HashSet<E> implements Set

interface SortedSet<E> extends Set {
    Comparator<? super E> comparator()
    SortedSet<E> subSet(E fromElement, E toElement)
    SortedSet<E> headSet(E toElement)
    SortedSet<E> tailSet(E fromElement)
}

interface NavigableSet<E> extends SortedSet {
    E lower(E e)
    E floor(E e)
    E ceiling(E e)
    E higher(E e)
}



class TreeSet<E> implements NavigableSet

class LinkedHashSet<E> extends HashSet

interface SortedMap<K,V> extends Map {

    Comparator<? super K> comparator()

    SortedMap<K,V> subMap(K fromKey, K toKey)

    SortedMap<K,V> headMap(K toKey)
    SortedMap<K,V> tailMap(K fromKey)
}

interface NavigableMap<K,V> extends SortedMap {

    Map.Entry<K,V> lowerEntry(K key)
    K lowerKey(K key)
    Map.Entry<K,V> floorEntry(K key)
    K floorKey(K key)
    Map.Entry<K,V> ceilingEntry(K key)
    K ceilingKey(K key)
    Map.Entry<K,V> higherEntry(K key)
    K higherKey(K key)
    Map.Entry<K,V> firstEntry()
    Map.Entry<K,V> lastEntry()
    Map.Entry<K,V> pollFirstEntry()
    Map.Entry<K,V> pollLastEntry()

    NavigableMap<K,V> descendingMap()
    NavigableSet<K> navigableKeySet()
    NavigableSet<K> descendingKeySet()

    SortedMap<K,V> subMap(K fromKey, K toKey)
    NavigableMap<K,V> headMap(K toKey, boolean inclusive)
    SortedMap<K,V> headMap(K toKey)
    NavigableMap<K,V> headMap(K toKey, boolean inclusive)
    SortedMap<K,V> tailMap(K fromKey)
    NavigableMap<K,V> tailMap(K fromKey, boolean inclusive)
}

class HashMap<K,V> implements Map

class TreeMap<K,V> implements NavigableMap

class Hashtable<K,V> implements Map

@enduml